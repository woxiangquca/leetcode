> 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
>
> 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

## 链表模拟

## 数学找规律

【思路】

- n个数字的圆圈，不断删除第m个数字，我们把最后剩下的数字的当前索引记为f(n,m)

- n个数字中第一个被删除的数字是(m-1)%n (取余的原因是m可能比n大)， 我们记作k，k=(m-1)%n

- 剩下的n-1个数字就变成了：0,1,……k-1,k+1,……,n-1，我们把下一轮第一个数字排在最前面，并且将这个长度为n-1的数组映射到0~n-2。

| 原始数字 | 映射数字 |
| -------- | -------- |
| k+1      | 0        |
| k+2      | 1        |
| ...      | ...      |
| n-1      | n-k-2    |
| 0        | n-k-1    |
| ...      | ...      |
| k-1      | n-2      |

- 把映射数字记为x，原始数字记为y，那么映射数字变回原始数字的公式为:

  ​																	$y = (x+k+1) \mod n$

- 最后剩下的数字的映射数组肯定是0，那么在上一轮删除时他的原始数字为k+1 mod n,这个数字又是上上一轮的映射数字，所以：
                                                          $f(n,m) =（f(n-1,m)+k+1)\mod n$

- 起始条件f(1,m) = 0，从一个数组中删去的索引肯定是0

```java
class Solution {
    public int lastRemaining(int n, int m) {
        int last = 0;   //存活的最后一个人的位置
        for (int i = 2; i <= n; i++) {
            last = (last + m) % i;
        }
        return last;
    }
}
```



